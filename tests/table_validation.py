import os
import sys
import yaml
from datetime import datetime
import psycopg2
sys.path.insert(1, '.')
from postgres.postgres import postgres
from logger.logger import log

logger=log(__name__)


class tableValidation:
    """Object to run table and database validations.
    """    
    def __init__(self,schema_name,table_name):
        self.table_name=table_name
        self.schema_name=schema_name
    
    def _query_output_dict_into_list(self,query_output:dict,key:str):
        """Helper function to parse query output into a list in cases 
        where you want output of a singular column in one single list. 

        Args:
            query_output (dict): Query output generated by the function postgres().sql()
            key (str): Column name

        Returns:
            list: List of all values in that column.
        """        
        list_of_relevant_values=[]
        for row in query_output:
            list_of_relevant_values.append(row[key])
        return list_of_relevant_values
    
    def column_contains_only_allowed_values(self,col_name:str,list_of_allowed_values:list):
        """Method to check if a column in table contains only specified values, as defined by the business process or OLTP.

        Args:
            col_name (str): Name of column
            list_of_allowed_values (list): List of values that the specified column can take

        Returns:
            bool: True if all column only has specified values, false if otherwise.
        """        
        if self.check_if_table_exists()==True:
            pass
        else:
            return False
        try:
            conn=postgres()._conn()
            cur=conn.cursor()
            list_of_allowed_values=tuple(list_of_allowed_values)
            query=f"""
                select count(*)
                from {self.schema_name}.{self.table_name}
                WHERE {col_name} NOT IN %s;
                    """
            cur.execute(query, (list_of_allowed_values,))
            result = cur.fetchone()[0]
            cur.close()
            conn.close()
            return result == 0
        except Exception:
            logger.exception('')
            return False
        
    def column_has_blanks(self,col_name:str):
        """Method to check if a specified column has blanks or null values

        Args:
            col_name (str): Name of column

        Returns:
            bool: True if it has blanks, False if otherwise.
        """        
        if self.check_if_table_exists()==True:
            pass
        else:
            return False
        try:
            conn=postgres()._conn()
            cur=conn.cursor()
            query = f"""
        SELECT COUNT(*) FROM {self.schema_name}.{self.table_name}
        WHERE {col_name} IS NULL OR {col_name} = '';
    """
            cur.execute(query)
            result = cur.fetchone()[0]
            return result > 0
        except Exception:
            logger.exception('')
            return False
    
    def date_column_in_consistent_format(self,date_col_name:str,date_format:str):
        """Method to check if a date column (in string format only) follows a consistent date format.

        Args:
            date_col_name (str): Name of date column
            date_format (str): Format of date 

        Returns:
            bool: True if all values are consistent, false if otherwise.
        """        
        query = f"SELECT {date_col_name} FROM {self.schema_name}.{self.table_name} WHERE {date_col_name} IS NOT NULL;"
        conn=postgres()._conn()
        cur=conn.cursor()
        try:
            cur.execute(query)
            rows = cur.fetchall()

            for row in rows:
                date_str = row[0]  
                try:
                    datetime.strptime(date_str, date_format) 
                except ValueError:
                    logger.info('Inconsistent date format detected!')
                    return False  
            return True  
        except psycopg2.Error as e:
            logger.exception('')
            return False
        finally:
            cur.close()
            conn.close()

    def check_if_schema_exists(self):
        """Used to check if a schema exists in the database

        Args:
            schema_name (str): Name of the schema. Does not include it's relevant staging table (dlt specific)

        Returns:
            bool: Returns True if the schema exists, else returns false.
        """        
        query=postgres().sql(sql='SELECT schema_name \
                                            FROM information_schema.schemata;',
                             output=True,file_path=False)
        if self.schema_name in self._query_output_dict_into_list(query,'schema_name'):
            return True
        else:
            return False

    
    def check_if_table_exists(self):
        """Function to check if a table is in a specified schema.

        Args:
            table_name (str): Name of the table.
            schema_name (str): Name of the schema.

        Returns:
            bool: Returns True if the table exists, else False.
        """        
        if self.table_name in self.list_of_tables():
            return True
        else:
            return False
    
    def check_if_table_has_data(self):
        """Method to see if a table in a specific column has 

        Args:
            table_name (str): Table name
            schema_name (str): Schema name

        Returns:
            bool: True if the table has data, else False.
        """ 
        if self.check_if_table_exists(self.table_name,self.schema_name)==True:
            pass
        else:
            logger.error('{0} in schema {1} does not exist.'.format(self.table_name,self.schema_name))
            return False
        query=postgres().sql('select exists (select * from {0}.{1} limit 1) as has_data'.format(self.schema_name,self.table_name),output=True,file_path=False)
        return query[0]['has_data']
    
    def list_of_tables(self):
        """Method to list all the tables in the schema.

        Args:
            schema_name (str): Schema where the tables are stored.

        Returns:
            list: List of table names.
        """    
        if self.check_if_schema_exists()==True:
            pass
        else:
            logger.error("'{0}' does not exist. Unable to pull tables.".format(self.schema_name)) 
            return None   
        query= postgres().sql(sql="SELECT table_name FROM information_schema.tables where table_schema = '{0}';".format(self.schema_name),
            output=True,file_path=False)
        return self._query_output_dict_into_list(query,'table_name')
    
    def list_of_all_columns(self):
        """Method returns a list of all the columns in the specified table and schema

        Args:
            table_name (str): Table name
            scheme_name (str): Schema name

        Returns:
            list: List of column names.
        """        
        if self.check_if_table_exists(self.table_name,self.scheme_name)==True:
            pass
        else:
            logger.error('Unable to pull column names due to non existent table {0} in schema {1}'.format(self.table_name,self.scheme_name))
            return None
        query=postgres().sql("SELECT distinct column_name \
            FROM information_schema.columns WHERE table_schema = '{0}' AND table_name = '{1}';".format(self.scheme_name,self.table_name),
            output=True,file_path=False)
        return self._query_output_dict_into_list(query,'column_name')
    
    def check_if_column_exists_in_table(self,column_name:str):
        """Method to check if a column exists in a table

        Args:
            column_name (str): Column name
            table_name (str): Table name
            schema_name (str): Schema name

        Returns:
            list: List of all columns in that table.
        """        
        if column_name in self.list_of_all_columns(self.table_name,self.schema_name):
            return True
        else:
            logger.error('{0} not found in table {1}.{2}'.format(column_name,self.schema_name,self.table_name))
            return False
        

